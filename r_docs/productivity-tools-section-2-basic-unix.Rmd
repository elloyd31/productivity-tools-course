---
title: 'Productivity Tools Section 2: Basic Unix'
author: "Erin Lloyd"
date: "29/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The examples here and in videos refer to this hypothetical file system

![Figure 2.1: Hypothetical file system](../images/hypothetical-file-system.png)

## 2.1 Introduction to Unix

### Organizing with Unix

### The Terminal

The terminal helps to organize files in the system.  

On Mac, use utilities > terminal.  

On windows, use Git bash program.  

Use the keyboard to navigate the command line.  


### The Filesystem

We refer to all the files, folders, and programs (executables) on your computer as the **filesystem**.  

Your filesystem is organized as a series of nested folders each containing files, folders, and executables. (see the visualization in the textbook)  

In Unix, folders are referred to as directories and directories that are inside other directories are often referred to as subdirectories.   

The home directory is where all your stuff is kept.  There is a hierarchical nature to the file system.  

**Note for Windows Users**: The typical R installation will make your Documents directory your home directory in R. This will likely be different from your home directory in Git Bash. Generally, when we discuss home directories, we refer to the Unix home directory which for Windows, in this book, is the Git Bash Unix directory.  


### Working Directory  

The working directory is the current location.  

Each terminal window has a working directory associated with it.  

The "pwd" command will display your working directory. The "/" symbol separates directories, while the first "/" at the beginning of the path stands for the root directory. When a path starts with "/", it is a "full path", which finds the current directory from the root directory. "Relative path" will be introduced soon.  

"~" means the home directory.  


## 2.2 Working with Unix

### Unix Commands

navigate the file system with commands introduced in this video.  

Auto-complete paths, commands and file names with the "Tab" key.  

ls #list dir content  

mkdir folder_name #create directory called "folder_name"  

rmdir folder_name  #remove an empty directory as long as it is empty  

rm -r folder_name  #remove dir that is not empty, "r" stands for recursive  

cd: change dir  

../ # two dots represents parent dir  

. # single dot represents current workingdir   

cd ~/projects # concatenate with forward slashes  

cd ../.. # change to two parent layer beyond  

cd -  # whatever dir you were before  

cd  # return to the home dir  


### mv and rm: Moving and Removing Files

The *mv* command moves files.  

**[warning]** mv will not ask you to confirm the move, and it could potentially overwrite a file.  

The *rm* command removes files.  

**[warning]** rm is permanent, which is different than throwing a folder in the trash.  


**Code**  
mv path-to-file path-to-destination-directory  

rm filename-1 filename-2 filename-3  


### less: Looking at a File

*less* allows you to quickly look at the content of a file  

Use *q* to exit the *less* page  

use the arrows to navigate in the *less* page  

**Code**  
less cv.tex  


### Preparing for a Data Science Project

Ideally, files (code, data, output) should be structured and self-contained  

In a project, we prefer using relative paths (path relative to the default working directory) instead of the full path so that code can run smoothly on other individual's computers.  

It is good practice to write a README.txt file to introduce the file structure to facilitate collaboration and for your future reference.  

#### Code

*In terminal*
cd ~    # move to home directory  
mkdir projects    # make a new directory called projects  
cd projects    # move to ~/projects directory  
mkdir murders    # make new directory called murders inside of projects  
cd murders    # move to ~/projects/murders/  
mkdir data rda    # make two new directories, one is data the other is rda folder  
ls    # to check if we indeed have one data folder and one rda folder  
pwd    # check the current working directory  
mkdir figs    # make a directory called figs to store figures  


*In RStudio* 
 # pick existing directory as new project  
getwd()    # to confirm current working directory  
save()    # save into .rda file, .RData is also fine but less preferred  
ggsave("figs/barplot.png")    # save a plot generated by ggplot2 to a dir called "figs"  

## Comprehension Check: Basic Unix

### Q1

It is important to know which directory, or folder, you’re in when you are working from the command line in Unix. Which line of code will tell you the current working directory?  

**Possible Answers**  

* *cd*  

* *pwd*  

* *rm*  

* *echo*  

**ANSWER: pwd**  
*This command stands for “print working directory” and it will tell you the full path to the directory you’re currently in.*  

### Q2

You can’t use your computer’s mouse in a terminal. How can you see a line of code that you executed previously?  

**Possible Answers**  

* Type *pwd*  

* Type *echo*  

* Use the up arrow  

* Press the enter key  

**ANSWER: Use the up arrow**  
*You can use the up arrow to see previously executed lines of code and repeat them.*  


### Q3

Assume a student types pwd and gets the following output printed to the screen: /Users/student/Documents.  

Then, the student enters the following commands in sequence:  

*mkdir projects*  

*cd projects*  

What will be printed to the screen if the student types pwd after executing the two lines of code shown above?  

**Possible Answers**  

* /Users/student/Documents  

* /Users/student/Documents/projects  

* /Users/student  

* cd: projects: No such file or directory  

**ANSWER: /Users/student/Documents/projects**  
*The student created a new directory called “projects” and then moved into that directory using the “change directory” (cd) command.*  


### Q4

Which of the following statements does NOT correctly describe the utility of a command in Unix?  

**Possible Answers**  

* The *q* key exits the viewer when you use *less* to view a file.  

* The command *ls* lists files in the current directory.  

* The command *mkdir* makes a new directory and moves into it.  

* The *mv* command can move a file and change the name of a file.  

**ANSWER: The command *mkdir* makes a new directory and moves into it.**  
*The mkdir command makes a new directory but does not automatically move into it. You must use the cd command to change into the new directory.*  


### Q5

The following is the full path to a homework assignment file called "assignment.txt": /Users/student/Documents/projects/homeworks/assignment.txt.  

Which line of code will allow you to move the assignment.txt file from the “homeworks” directory into the parent directory “projects”?  

**Possible Answers**  

* mv assignment.txt  

* mv assignment.txt .  

* mv assignment.txt ..  

* mv assignment.txt /projects  

**ANSWER: mv assignment.txt ..**  
*Double dots .. mean “up a directory”, so mv assignment.txt .. moves the assignment text file into the NEXT highest directory, projects.*  

### Q6

You want to move a file called *assignment.txt* into your projects directory. However, there is already a file called "assignment.txt" in the *projects* directory.  

What happens when you execute the “move” (mv) command to move the file into the new directory?  

**Possible Answers**  

* The moved "assignment.txt" file replaces the old "assignment.txt" file that was in the "projects" directory with no warning.  

* An error message warns you that you are about to overwrite an existing file and asks if you want to proceed.  

* An error message tells you that a file already exists with that name and asks you to rename the new file.  

* The moved “assignment.txt” file is automatically renamed “assignment.txt (copy)” after it is moved into the “projects” directory.  

**ANSWER: The moved "assignment.txt" file replaces the old "assignment.txt" file that was in the "projects" directory with no warning. **  
*Be careful when moving files around using the command line. Unix does not warn you before you overwrite a file.*  

### Q7

What does each of ~, ., .., / represent, respectively?  

**Possible Answers**  

* Current directory, Home directory, Root directory, Parent directory  

* Home directory, Current directory, Parent directory, Root directory  

* Home directory, Hidden directory, Parent directory, Root directory  

* Root directory, Current directory, Parent directory, Home directory  

* Home directory, Parent directory, Home directory, Root directory  

**ANSWER: Home directory, Current directory, Parent directory, Root directory**  


### Q8

Suppose you want to delete your project directory at ./myproject. The directory is not empty - there are still files inside of it.  

Which command should you use?  

**Possible Answers**  

* rmdir myproject  

* rmdir ./myproject  

* rm -r myproject  

* rm ./myproject  

**ANSWER: rm -r myproject**  


### Q9

The *source()* function reads a script from a url or file and evaluates it. Check *?source* in the R console for more information.  

Suppose you have an R script at *~/myproject/R/plotfig.R* and *getwd()* shows *~/myproject/result*, and you are running your R script with *source('~/myproject/R/plotfig.R')*.  

Which R function should you write in plotfig.R in order to correctly produce a plot in *~/myproject/result/fig/barplot.png*?  

**Possible Answers**  

* *ggsave('fig/barplot.png')*, because this is the relative path to the current working directory.  

* *ggsave('../result/fig/barplot.png')*, because this is the relative path to the source file ("plotfig.R").  

* *ggsave('result/fig/barplot.png')*, because this is the relative path to the project directory.  

* *ggsave('barplot.png')*, because this is the file name.  

**ANSWER: ggsave('fig/barplot.png'), because this is the relative path to the current working directory.**  


### Q10

Which of the following statements about the terminal are not correct? Select ALL that apply.  

**Possible Answers**  

* *echo* is similar to *cat* and can be used to print.  

* The up arrow can be used to go back to a command you just typed.  

* You can click on the terminal to change the position of the cursor  

* For a long command that spans three lines, we can use the up-arrow to navigate the cursor to the first line.  

**ANSWER: You can click on the terminal to change the position of the cursor; For a long command that spans three lines, we can use the up-arrow to navigate the cursor to the first line.  **  


### Q11

Which of the following statements about the filesystem is not correct?  

**Possible Answers**  

* The home directory is where the system files that come with your computer exist.  

* The name of the home directory is likely the same as the username on the system.  

* File systems on Windows and Mac are different in some ways.  

* Root directory is the directory that contains all directories.  

**ANSWER: The home directory is where the system files that come with your computer exist.**  


### Q12

Which of the following meanings for options following less are not correct? (Hint: use *man less* to check.)  

**Possible Answers**  

* *-g*: Highlights current match of any searched string  

* *-i*: case-insensitive searches  

* *-S*: automatically save the search object  

* *-X*: leave file contents on screen when less exits.  

**ANSWER: *-S*: automatically save the search object**  

-g or --hilite-search
              Normally, less will highlight ALL strings which match the last  search  com-
              mand.   The -g option changes this behavior to highlight only the particular
              string which was found by the last search command.  This can cause  less  to
              run somewhat faster than the default.  
              
-i or --ignore-case
              Causes searches to ignore case; that is, uppercase and lowercase are consid-
              ered identical.  This option is ignored if any uppercase letters  appear  in
              the search pattern; in other words, if a pattern contains uppercase letters,
              then that search does not ignore case.  

-S or --chop-long-lines
              Causes lines longer than the screen width to be chopped  (truncated)  rather
              than  wrapped.  That is, the portion of a long line that does not fit in the
              screen width is not shown.  The default is to wrap long lines; that is, dis-
              play the remainder on the next line.  

-X or --no-init
              Disables  sending the termcap initialization and deinitialization strings to
              the terminal.  This is sometimes desirable if  the  deinitialization  string
              does something unnecessary, like clearing the screen.


### Q13

Which of the following statements is incorrect about preparation for a data science project? Select ALL that apply.  

**Possible Answers**  

* Always use absolute paths when working on a data science project.  

* Saving .RData every time you exit R will keep your collaborator informed of what you did.  

* Use ggsave to save generated files for use in a presentation or a report.  

* Saving your code in a Word file and inserting output images is a good idea for making a reproducible report.  

**ANSWER: Always use absolute paths when working on a data science project; Saving .RData every time you exit R will keep your collaborator informed of what you did; Saving your code in a Word file and inserting output images is a good idea for making a reproducible report.**  

## Additional notes

### Absolute path vs. relative path

A *full path* specifies the location of a file from the root directory. It is independent of your present directory, and must begin with either a “/” or a “~”. In this example, the full path to our “project-1” file is:  

*/home/projects/project-1*  

A *relative path* is the path relative to your present working directory. If our present working directory is the “projects” folder, then the relative path to our “project-1” file is simply:  

*project-1*  

#### Path shortcuts

One period “.” is your current working directory  

Two periods “..” is the parent directory (up one from your present working directory)   

A tilde   “~” is your home directory.  

#### More path examples

1. Your current working directory is *~/projects* and you want to move to the figs directory in the *project-1* folder  

    + Solution 1: *cd ~/projects/project-1/figs* (absolute)  

    + Solution 2: *cd project-1/figs* (relative)  

2. Your current working directory is *~/projects* and you want to move to the reports folder in the *docs* directory  

    + Solution 1: *cd ~/dos/reports* (absolute)  
    
    + Solution 2: *cd ../docs/reports* (relative)  

3. Your current working directory is *~/projects/project-1/figs* and you want to move to the *project-2* folder in the projects directory.  

    + Solution 1: *cd ~/projects/project-2* (absolute)  

    + Solution 2: *cd ../../project-2* (relative)  



